/*
Copyright 2021 The KubeDiag Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cronscheduler

import (
	"context"
	"fmt"
	"time"

	"github.com/go-logr/logr"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/robfig/cron"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"sigs.k8s.io/controller-runtime/pkg/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/metrics"

	diagnosisv1 "github.com/kubediag/kubediag/api/v1"
	"github.com/kubediag/kubediag/pkg/util"
)

var (
	// CronDiagnosisPrefix is the name prefix for diagnoses generated by cron trigger.
	CronDiagnosisPrefix = "cron"
	// CronAnnotation is the annotation used to store the cron that triggers a diagnosis.
	CronAnnotation = util.KubeDiagPrefix + CronDiagnosisPrefix
)

var (
	cronDiagnosisGenerationSuccessCount = prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "cron_diagnosis_generation_success_count",
			Help: "Counter of successful diagnosis generations by cron trigger",
		},
	)
	cronDiagnosisGenerationErrorCount = prometheus.NewCounter(
		prometheus.CounterOpts{
			Name: "cron_diagnosis_generation_error_count",
			Help: "Counter of erroneous diagnosis generations by cron trigger",
		},
	)
)

// CronScheduler generates diagnoses periodically at fixed times.
type CronScheduler interface {
	// Run runs the CronScheduler.
	Run(context.Context)
}

// cronScheduler manages crons.
type cronScheduler struct {
	// Context carries values across API boundaries.
	context.Context
	// Logger represents the ability to log messages.
	logr.Logger

	// client knows how to perform CRUD operations on Kubernetes objects.
	client client.Client
	// cache knows how to load Kubernetes objects.
	cache cache.Cache
	// cronSchedulerEnabled indicates whether cron scheduler is enabled.
	cronSchedulerEnabled bool
}

// NewCronScheduler creates a new CronScheduler.
func NewCronScheduler(
	ctx context.Context,
	logger logr.Logger,
	cli client.Client,
	cache cache.Cache,
	cronSchedulerEnabled bool,
) CronScheduler {
	metrics.Registry.MustRegister(
		cronDiagnosisGenerationSuccessCount,
		cronDiagnosisGenerationErrorCount,
	)

	return &cronScheduler{
		Context:              ctx,
		Logger:               logger,
		client:               cli,
		cache:                cache,
		cronSchedulerEnabled: cronSchedulerEnabled,
	}
}

// Run runs the cron scheduler.
func (cs *cronScheduler) Run(ctx context.Context) {
	if !cs.cronSchedulerEnabled {
		return
	}

	// Wait for all caches to sync before processing.
	if !cs.cache.WaitForCacheSync(ctx) {
		return
	}

	go wait.Until(cs.sync, 1*time.Minute, ctx.Done())
	<-ctx.Done()
	cs.Info("shutting down cron scheduler")
}

func (cs *cronScheduler) sync() {
	triggers, err := cs.listTriggers()
	if err != nil {
		cs.Error(err, "failed to list Triggers")
		return
	}

	cronTriggers := cs.getCronTriggers(triggers)
	if len(cronTriggers) == 0 {
		return
	}
	for _, trigger := range cronTriggers {
		diagnosis, err := cs.createDiagnosisFromCron(trigger)
		if err != nil {
			// Increment counter of erroneous diagnosis generations by cron scheduler.
			cronDiagnosisGenerationErrorCount.Inc()
			return
		}

		if diagnosis != nil {
			cs.Info("creating Diagnosis from cron successfully", "diagnosis", client.ObjectKey{
				Name:      diagnosis.Name,
				Namespace: diagnosis.Namespace,
			})

			// Update last schedule time of cron trigger.
			err := cs.client.Get(cs, client.ObjectKey{
				Name: trigger.Name,
			}, &trigger)
			if err != nil {
				if apierrors.IsNotFound(err) {
					return
				}
				cs.Error(err, "unable to get Trigger")
				cronDiagnosisGenerationErrorCount.Inc()
				return
			}

			now := time.Now()
			trigger.Status.LastScheduleTime = &metav1.Time{Time: now}
			if err := cs.client.Status().Update(cs, &trigger); err != nil {
				cs.Error(err, "unable to update Trigger")
				cronDiagnosisGenerationErrorCount.Inc()
				return
			}

			// Increment counter of successful diagnosis generations by cron scheduler.
			cronDiagnosisGenerationSuccessCount.Inc()
		}
	}
}

// listTriggers lists Triggers from cache.
func (cs *cronScheduler) listTriggers() ([]diagnosisv1.Trigger, error) {
	var triggersList diagnosisv1.TriggerList
	if err := cs.cache.List(cs, &triggersList); err != nil {
		return nil, err
	}

	return triggersList.Items, nil
}

// getCronTriggers gets cron triggers from the trigger list.
func (cs *cronScheduler) getCronTriggers(triggers []diagnosisv1.Trigger) []diagnosisv1.Trigger {
	cronTriggers := make([]diagnosisv1.Trigger, 0)
	for _, trigger := range triggers {
		if trigger.Spec.SourceTemplate.CronTemplate != nil {
			cronTriggers = append(cronTriggers, trigger)
		}
	}

	return cronTriggers
}

// createDiagnosisFromCron creates a Diagnosis from the cron trigger.
func (cs *cronScheduler) createDiagnosisFromCron(trigger diagnosisv1.Trigger) (*diagnosisv1.Diagnosis, error) {
	sourceTemplate := trigger.Spec.SourceTemplate
	if sourceTemplate.CronTemplate != nil {
		now := time.Now()
		times, err := cs.getRecentUnmetScheduleTimes(trigger, now)
		if err != nil {
			cs.Error(err, "cannot determine if cron needs to be started", "trigger", trigger.Name)
			return nil, err
		}

		if len(times) == 0 {
			// No unmet start times found.
			return nil, nil
		}

		cs.Info("creating Diagnosis from cron", "cron", sourceTemplate.CronTemplate.Schedule, "trigger", trigger.Name)

		// Create diagnosis according to the cron.
		name := fmt.Sprintf("%s.%s.%d", CronDiagnosisPrefix, trigger.Name, now.Unix())
		namespace := util.DefautlNamespace
		annotations := make(map[string]string)
		annotations[CronAnnotation] = sourceTemplate.CronTemplate.Schedule
		diagnosis := diagnosisv1.Diagnosis{
			ObjectMeta: metav1.ObjectMeta{
				Name:        name,
				Namespace:   namespace,
				Annotations: annotations,
			},
			Spec: diagnosisv1.DiagnosisSpec{
				Parameters:   trigger.Spec.Parameters,
				OperationSet: trigger.Spec.OperationSet,
				NodeName:     trigger.Spec.NodeName,
			},
		}

		if err := cs.client.Create(cs, &diagnosis); err != nil {
			if !apierrors.IsAlreadyExists(err) {
				cs.Error(err, "unable to create Diagnosis")
				return &diagnosis, err
			}
		}

		return &diagnosis, nil
	}

	return nil, nil
}

// getRecentUnmetScheduleTimes gets a slice of times (from oldest to latest) that have passed when a Diagnosis should have started but did not.
//
// If there are too many (>100) unstarted times, just give up and return an empty slice.
// If there were missed times prior to the last known start time, then those are not returned.
// This function is inspired by https://github.com/kubernetes/kubernetes/blob/v1.19.16/pkg/controller/cronjob/utils.go#L92.
func (cs *cronScheduler) getRecentUnmetScheduleTimes(trigger diagnosisv1.Trigger, now time.Time) ([]time.Time, error) {
	starts := []time.Time{}
	sched, err := cron.ParseStandard(trigger.Spec.SourceTemplate.CronTemplate.Schedule)
	if err != nil {
		return starts, fmt.Errorf("unparseable schedule: %s : %s", trigger.Spec.SourceTemplate.CronTemplate.Schedule, err)
	}

	var earliestTime time.Time
	if trigger.Status.LastScheduleTime != nil {
		earliestTime = trigger.Status.LastScheduleTime.Time
	} else {
		// If none found, then this is either a recently created cron trigger, or the active/completed info was
		// somehow lost (contract for status in kubernetes says it may need to be recreated), or that we have
		// started a diagnosis, but have not noticed it yet (distributed systems can have arbitrary delays).
		// In any case, use the creation time of the trigger as last known start time.
		earliestTime = trigger.ObjectMeta.CreationTimestamp.Time
	}
	if earliestTime.After(now) {
		return []time.Time{}, nil
	}

	for t := sched.Next(earliestTime); !t.After(now); t = sched.Next(t) {
		starts = append(starts, t)
		// An object might miss several starts. For example, if controller gets wedged on friday at 5:01pm
		// when everyone has gone home, and someone comes in on tuesday AM and discovers the problem and restarts
		// the controller, then all the hourly crons, more than 80 of them for one hourly cron, should
		// all start running with no further intervention (if the cron allows concurrency and late starts).
		//
		// However, if there is a bug somewhere, or incorrect clock on controller's server or apiservers (for
		// setting creationTimestamp) then there could be so many missed start times (it could be off by decades
		// or more), that it would eat up all the CPU and memory of this controller. In that case, we want to
		// not try to list all the missed start times.
		//
		// I've somewhat arbitrarily picked 100, as more than 80, but less than "lots".
		if len(starts) > 100 {
			// We can't get the most recent times so just return an empty slice.
			return []time.Time{}, fmt.Errorf("too many missed start time (> 100)")
		}
	}

	return starts, nil
}
