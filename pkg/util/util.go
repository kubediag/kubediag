/*
Copyright 2020 The Kube Diagnoser Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/go-logr/logr"
	"github.com/prometheus/common/model"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/client-go/transport"
	"sigs.k8s.io/controller-runtime/pkg/client"

	diagnosisv1 "github.com/kube-diagnoser/kube-diagnoser/api/v1"
	"github.com/kube-diagnoser/kube-diagnoser/pkg/types"
)

const (
	// PodInformationContextKey is the key of pod information in diagnosis context.
	PodInformationContextKey = "podInformation"
	// ContainerInformationContextKey is the key of container information in diagnosis context.
	ContainerInformationContextKey = "containerInformation"
	// ProcessInformationContextKey is the key of process information in diagnosis context.
	ProcessInformationContextKey = "processInformation"
	// FilePathInformationContextKey is the key of file path information in diagnosis context.
	FilePathInformationContextKey = "filePathInformation"
	// FileStatusInformationContextKey is the key of file information in diagnosis context.
	FileStatusInformationContextKey = "fileStatusInformation"
	// SystemdUnitNameInformationContextKey is the key of systemd unit name information in diagnosis context.
	SystemdUnitNameInformationContextKey = "systemdUnitNameInformationContextKey"
	// SystemdUnitPropertyInformationContextKey is the key of systemd unit property information in diagnosis context.
	SystemdUnitPropertyInformationContextKey = "systemdUnitPropertyInformationContextKey"
	// PodDiskUsageDiagnosisContextKey is the key of pod disk usage diagnosis result in diagnosis context.
	PodDiskUsageDiagnosisContextKey = "podDiskUsageDiagnosis"
	// TerminatingPodDiagnosisContextKey is the key of terminating pod diagnosis result in diagnosis context.
	TerminatingPodDiagnosisContextKey = "terminatingPodDiagnosis"
	// SignalRecoveryContextKey is the key of process signal recovery details in diagnosis context.
	SignalRecoveryContextKey = "signalRecovery"
	// ProfilerEndpointExpiredValue is the value of endpoint in profiler status after expiration duration.
	ProfilerEndpointExpiredValue = "expired"
	// MaxDataSize specifies max size of data which could be processed by kube diagnoser.
	// It is the message size limitation in grpc: https://github.com/grpc/grpc-go/blob/v1.30.0/clientconn.go#L95.
	MaxDataSize = 1024 * 1024 * 2
	// KubeletRunDirectory specifies the directory where the kubelet runtime information is stored.
	KubeletRunDirectory = "/var/lib/kubelet"
	// KubeletPodDirectory specifies the directory where the kubelet pod information is stored.
	KubeletPodDirectory = "/var/lib/kubelet/pods"
	// DefautlNamespace is the default namespace of kube diagnoser.
	DefautlNamespace = "kube-diagnoser"
	// DefautlPodCollector is the default name of pod collector.
	DefautlPodCollector = "pod-collector"
	// DefautlProcessCollector is the default name of process collector.
	DefautlProcessCollector = "process-collector"
	// DefautlTerminatingPodDiagnoser is the default name of terminating pod diagnoser.
	DefautlTerminatingPodDiagnoser = "terminating-pod-diagnoser"
	// DefautlSignalRecoverer is the default name of signal recoverer.
	DefautlSignalRecoverer = "signal-recoverer"
	// PrometheusAlertGeneratedDiagnosisPrefix is the name prefix for diagnoses generated by prometheus alerts.
	PrometheusAlertGeneratedDiagnosisPrefix = "prometheus-alert"
	// KubernetesEventGeneratedDiagnosisPrefix is the name prefix for diagnoses generated by kubernetes events.
	KubernetesEventGeneratedDiagnosisPrefix = "kubernetes-event"
	// PodKillGracePeriodSeconds is the duration in seconds after the pod is forcibly halted
	// with a kill signal and the time when the pod is taken as an abormal pod.
	PodKillGracePeriodSeconds = 30
	// TerminatingPodDiagnosisNamePrefix is the name prefix for creating terminating pod diagnosis.
	TerminatingPodDiagnosisNamePrefix = "terminating-pod"
	// MemoryAnalyzerLeakSuspectsReportAPI is the eclipse memory analyzer api for leak suspects report.
	MemoryAnalyzerLeakSuspectsReportAPI = "org.eclipse.mat.api:suspects"
	// MemoryAnalyzerSystemOverviewReportAPI is the eclipse memory analyzer api for system overview report.
	MemoryAnalyzerSystemOverviewReportAPI = "org.eclipse.mat.api:overview"
	// MemoryAnalyzerTopComponentsReportAPI is the eclipse memory analyzer api for top components report.
	MemoryAnalyzerTopComponentsReportAPI = "org.eclipse.mat.api:top_components"
	// MemoryAnalyzerLeakSuspectsSuffix is the suffix for leak suspects report directory.
	MemoryAnalyzerLeakSuspectsSuffix = "_Leak_Suspects"
	// MemoryAnalyzerSystemOverviewSuffix is the suffix for system overview report directory.
	MemoryAnalyzerSystemOverviewSuffix = "_System_Overview"
	// MemoryAnalyzerTopComponentsSuffix is the suffix for top components report directory.
	MemoryAnalyzerTopComponentsSuffix = "_Top_Components"
	// MemoryAnalyzerHomepage is the html text for memory analyzer homepage.
	MemoryAnalyzerHomepage = `<h2>Eclipse Memory Analyzer</h2><ul><li><a href="/leaksuspects/">Leak Suspects</a></li><li><a href="/systemoverview/">System Overview</a></li><li><a href="/topcomponents/">Top Components</a></li></ul>`
)

// UpdateDiagnosisCondition updates existing diagnosis condition or creates a new one. Sets
// LastTransitionTime to now if the status has changed.
// Returns true if diagnosis condition has changed or has been added.
func UpdateDiagnosisCondition(status *diagnosisv1.DiagnosisStatus, condition *diagnosisv1.DiagnosisCondition) bool {
	condition.LastTransitionTime = metav1.Now()
	// Try to find this diagnosis condition.
	conditionIndex, oldCondition := GetDiagnosisCondition(status, condition.Type)

	if oldCondition == nil {
		// We are adding new diagnosis condition.
		status.Conditions = append(status.Conditions, *condition)
		return true
	}

	// We are updating an existing condition, so we need to check if it has changed.
	if condition.Status == oldCondition.Status {
		condition.LastTransitionTime = oldCondition.LastTransitionTime
	}

	isEqual := condition.Status == oldCondition.Status &&
		condition.Reason == oldCondition.Reason &&
		condition.Message == oldCondition.Message &&
		condition.LastTransitionTime.Equal(&oldCondition.LastTransitionTime)

	status.Conditions[conditionIndex] = *condition

	// Return true if one of the fields have changed.
	return !isEqual
}

// GetDiagnosisCondition extracts the provided condition from the given status.
// Returns -1 and nil if the condition is not present, otherwise returns the index of the located condition.
func GetDiagnosisCondition(status *diagnosisv1.DiagnosisStatus, conditionType diagnosisv1.DiagnosisConditionType) (int, *diagnosisv1.DiagnosisCondition) {
	if status == nil {
		return -1, nil
	}

	return GetDiagnosisConditionFromList(status.Conditions, conditionType)
}

// GetDiagnosisConditionFromList extracts the provided condition from the given list of condition and
// returns the index of the condition and the condition. Returns -1 and nil if the condition is not present.
func GetDiagnosisConditionFromList(conditions []diagnosisv1.DiagnosisCondition, conditionType diagnosisv1.DiagnosisConditionType) (int, *diagnosisv1.DiagnosisCondition) {
	if conditions == nil {
		return -1, nil
	}
	for i := range conditions {
		if conditions[i].Type == conditionType {
			return i, &conditions[i]
		}
	}

	return -1, nil
}

// GetPodUnhealthyReason extracts the reason of terminated or waiting container in the pod if the pod is
// not ready. The parameter must be an unhealthy pod.
// It returns the reason of the first terminated or waiting container.
func GetPodUnhealthyReason(pod corev1.Pod) string {
	// Return the reason of the first terminated or waiting container.
	for _, containerStatus := range pod.Status.ContainerStatuses {
		// Skip ready containers.
		if containerStatus.Ready {
			continue
		}

		if containerStatus.State.Terminated != nil {
			return containerStatus.State.Terminated.Reason
		} else if containerStatus.State.Waiting != nil {
			return containerStatus.State.Waiting.Reason
		}
	}

	// Return the reason of the first unready container if last termination state is documented.
	for _, containerStatus := range pod.Status.ContainerStatuses {
		// Skip ready containers.
		if containerStatus.Ready {
			continue
		}

		if containerStatus.LastTerminationState.Terminated != nil {
			return containerStatus.LastTerminationState.Terminated.Reason
		}
	}

	// The pod unhealthy reason will be Unknown if no unhealthy container status is reported.
	return "Unknown"
}

// UpdatePodUnhealthyReasonStatistics updates container state reason map of unhealthy pods.
// It returns true if the reason is not empty, otherwise false.
func UpdatePodUnhealthyReasonStatistics(containerStateReasons map[string]int, reason string) bool {
	if containerStateReasons == nil {
		containerStateReasons = make(map[string]int)
	}

	if reason == "" {
		return false
	}
	containerStateReasons[reason]++

	return true
}

// IsNodeReady returns true if its Ready condition is set to true and it does not have NetworkUnavailable
// condition set to true.
func IsNodeReady(node corev1.Node) bool {
	nodeReady := false
	networkReady := true
	for _, condition := range node.Status.Conditions {
		if condition.Type == corev1.NodeReady {
			if condition.Status == corev1.ConditionTrue {
				nodeReady = true
			}
		}
		if condition.Type == corev1.NodeNetworkUnavailable {
			if condition.Status == corev1.ConditionTrue {
				networkReady = false
			}
		}
	}

	return nodeReady && networkReady
}

// GetNodeUnhealthyConditionType extracts the condition type of unhealthy node. The parameter must be an
// unhealthy node.
// It returns the type of the first unhealthy condition.
func GetNodeUnhealthyConditionType(node corev1.Node) corev1.NodeConditionType {
	for _, condition := range node.Status.Conditions {
		// Return the reason of the first unhealthy condition.
		if condition.Type != corev1.NodeReady && condition.Status == corev1.ConditionTrue {
			return condition.Type
		}
	}

	// The node condition will be Unknown if no unhealthy condition is reported.
	return "Unknown"
}

// FormatURL formats a URL from args.
func FormatURL(scheme string, host string, port string, path string) *url.URL {
	u, err := url.Parse(path)
	// Something is busted with the path, but it's too late to reject it. Pass it along as is.
	if err != nil {
		u = &url.URL{
			Path: path,
		}
	}

	u.Scheme = scheme
	u.Host = net.JoinHostPort(host, port)

	return u
}

// DoHTTPRequestWithDiagnosis sends a http request to diagnoser, recoverer or information collector with payload of diagnosis.
// It returns an Diagnosis and an error as results.
func DoHTTPRequestWithDiagnosis(diagnosis diagnosisv1.Diagnosis, url *url.URL, cli http.Client, log logr.Logger) (diagnosisv1.Diagnosis, error) {
	data, err := json.Marshal(diagnosis)
	if err != nil {
		return diagnosis, err
	}

	req, err := http.NewRequest("POST", url.String(), bytes.NewBuffer(data))
	if err != nil {
		return diagnosis, err
	}

	res, err := cli.Do(req)
	if err != nil {
		return diagnosis, err
	}
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Error(err, "failed to read http response body", "response", string(body))
		return diagnosis, err
	}

	// Return error if diagnosis size exceeds max data size.
	if len(body) > MaxDataSize {
		return diagnosis, fmt.Errorf("diagnosis data size %d exceeds max data size %d", len(body), MaxDataSize)
	}

	if res.StatusCode == http.StatusOK {
		err = json.Unmarshal(body, &diagnosis)
		if err != nil {
			log.Error(err, "failed to marshal response body", "response", string(body))
			return diagnosis, err
		}

		log.Info("succeed to complete http request", "diagnosis", client.ObjectKey{
			Name:      diagnosis.Name,
			Namespace: diagnosis.Namespace,
		}, "status", res.Status)
		return diagnosis, nil
	}

	log.Info("failed to complete http request", "status", res.Status, "response", string(body))
	return diagnosis, fmt.Errorf("failed with status: %s", res.Status)
}

// ListPodsFromPodInformationContext lists all pods on the node by retrieving context in diagnosis.
func ListPodsFromPodInformationContext(diagnosis diagnosisv1.Diagnosis, log logr.Logger) ([]corev1.Pod, error) {
	log.Info("listing pods")

	// Retrieve value from status context if context key is not found in spec context.
	data, err := GetDiagnosisSpecContext(diagnosis, PodInformationContextKey)
	if err != nil {
		data, err = GetDiagnosisStatusContext(diagnosis, PodInformationContextKey)
		if err != nil {
			return nil, err
		}
	}

	var pods []corev1.Pod
	err = json.Unmarshal(data, &pods)
	if err != nil {
		return nil, err
	}

	return pods, nil
}

// ListFilePathsFromFilePathInformationContext lists file paths by retrieving context in diagnosis.
func ListFilePathsFromFilePathInformationContext(diagnosis diagnosisv1.Diagnosis, log logr.Logger) ([]string, error) {
	log.Info("listing file paths")

	// Retrieve value from status context if context key is not found in spec context.
	data, err := GetDiagnosisSpecContext(diagnosis, FilePathInformationContextKey)
	if err != nil {
		data, err = GetDiagnosisStatusContext(diagnosis, FilePathInformationContextKey)
		if err != nil {
			return nil, err
		}
	}

	var filepaths []string
	err = json.Unmarshal(data, &filepaths)
	if err != nil {
		return nil, err
	}

	return filepaths, nil
}

// ListProcessesFromProcessInformationContext list processes by retrieving context in diagnosis.
func ListProcessesFromProcessInformationContext(diagnosis diagnosisv1.Diagnosis, log logr.Logger) ([]types.Process, error) {
	log.Info("listing processes")

	// Retrieve value from status context if context key is not found in spec context.
	data, err := GetDiagnosisSpecContext(diagnosis, ProcessInformationContextKey)
	if err != nil {
		data, err = GetDiagnosisStatusContext(diagnosis, ProcessInformationContextKey)
		if err != nil {
			return nil, err
		}
	}

	var processes []types.Process
	err = json.Unmarshal(data, &processes)
	if err != nil {
		return nil, err
	}

	return processes, nil
}

// ListSystemdUnitNamesFromProcessInformationContext list systemd unit names by retrieving context in diagnosis.
func ListSystemdUnitNamesFromProcessInformationContext(diagnosis diagnosisv1.Diagnosis, log logr.Logger) ([]string, error) {
	log.Info("listing systemd unit names")

	// Retrieve value from status context if context key is not found in spec context.
	data, err := GetDiagnosisSpecContext(diagnosis, SystemdUnitNameInformationContextKey)
	if err != nil {
		data, err = GetDiagnosisStatusContext(diagnosis, SystemdUnitNameInformationContextKey)
		if err != nil {
			return nil, err
		}
	}

	var units []string
	err = json.Unmarshal(data, &units)
	if err != nil {
		return nil, err
	}

	return units, nil
}

// ListSignalsFromSignalRecoveryContext list process signal details by retrieving context in diagnosis.
func ListSignalsFromSignalRecoveryContext(diagnosis diagnosisv1.Diagnosis, log logr.Logger) (types.SignalList, error) {
	log.Info("listing signals")

	// Retrieve value from status context if context key is not found in spec context.
	data, err := GetDiagnosisSpecContext(diagnosis, SignalRecoveryContextKey)
	if err != nil {
		data, err = GetDiagnosisStatusContext(diagnosis, SignalRecoveryContextKey)
		if err != nil {
			return nil, err
		}
	}

	var signals types.SignalList
	err = json.Unmarshal(data, &signals)
	if err != nil {
		return nil, err
	}

	return signals, nil
}

// ValidateDiagnosisResult validates an diagnosis after processed by a diagnoser, recoverer or information collector.
// The following fields must not be modified after processed:
//
// Spec
// Status.Identifiable
// Status.Recoverable
// Status.Phase
// Status.Conditions
// Status.Message
// Status.Reason
// Status.StartTime
// Status.Diagnoser
// Status.Recoverer
func ValidateDiagnosisResult(result diagnosisv1.Diagnosis, current diagnosisv1.Diagnosis) error {
	if !reflect.DeepEqual(result.Spec, current.Spec) {
		return fmt.Errorf("spec field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Identifiable, current.Status.Identifiable) {
		return fmt.Errorf("identifiable field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Recoverable, current.Status.Recoverable) {
		return fmt.Errorf("recoverable field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Phase, current.Status.Phase) {
		return fmt.Errorf("phase field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Conditions, current.Status.Conditions) {
		return fmt.Errorf("conditions field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Message, current.Status.Message) {
		return fmt.Errorf("message field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Reason, current.Status.Reason) {
		return fmt.Errorf("reason field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.StartTime, current.Status.StartTime) {
		return fmt.Errorf("startTime field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Diagnoser, current.Status.Diagnoser) {
		return fmt.Errorf("diagnoser field of Diagnosis must not be modified")
	}
	if !reflect.DeepEqual(result.Status.Recoverer, current.Status.Recoverer) {
		return fmt.Errorf("recoverer field of Diagnosis must not be modified")
	}

	return nil
}

// QueueDiagnosis sends an diagnosis to a channel. It returns an error if the channel is blocked.
func QueueDiagnosis(ctx context.Context, channel chan diagnosisv1.Diagnosis, diagnosis diagnosisv1.Diagnosis) error {
	select {
	case <-ctx.Done():
		return nil
	case channel <- diagnosis:
		return nil
	default:
		return fmt.Errorf("channel is blocked")
	}
}

// QueueDiagnosisWithTimer sends an diagnosis to a channel after a timer expires.
func QueueDiagnosisWithTimer(ctx context.Context, duration time.Duration, channel chan diagnosisv1.Diagnosis, diagnosis diagnosisv1.Diagnosis) error {
	timer := time.NewTimer(duration)
	select {
	case <-ctx.Done():
		return nil
	case <-timer.C:
		return QueueDiagnosis(ctx, channel, diagnosis)
	}
}

// QueueEvent sends an event to a channel. It returns an error if the channel is blocked.
func QueueEvent(ctx context.Context, channel chan corev1.Event, event corev1.Event) error {
	select {
	case <-ctx.Done():
		return nil
	case channel <- event:
		return nil
	default:
		return fmt.Errorf("channel is blocked")
	}
}

// IsDiagnosisNodeNameMatched checks if the diagnosis is on the specific node.
// It returns true if node name of the diagnosis is empty or matches provided node name, otherwise false.
func IsDiagnosisNodeNameMatched(diagnosis diagnosisv1.Diagnosis, nodeName string) bool {
	return diagnosis.Spec.NodeName == "" || diagnosis.Spec.NodeName == nodeName
}

// SetDiagnosisSpecContext sets spec context field of an diagnosis with provided key and value.
func SetDiagnosisSpecContext(diagnosis diagnosisv1.Diagnosis, key string, value interface{}) (diagnosisv1.Diagnosis, error) {
	if diagnosis.Spec.Context == nil {
		diagnosis.Spec.Context = new(runtime.RawExtension)
	}
	current, err := diagnosis.Spec.Context.MarshalJSON()
	if err != nil {
		return diagnosis, err
	}

	// Parsed context will be nil if raw data is empty.
	// Use map[string]interface{} instead of map[string][]byte for readability in json or yaml format.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return diagnosis, err
	}

	// Reinitialize context if context is nil.
	if context == nil {
		context = make(map[string]interface{})
	}
	context[key] = value
	result, err := json.Marshal(context)
	if err != nil {
		return diagnosis, err
	}

	err = diagnosis.Spec.Context.UnmarshalJSON(result)
	if err != nil {
		return diagnosis, err
	}

	return diagnosis, nil
}

// SetDiagnosisStatusContext sets status context field of an diagnosis with provided key and value.
func SetDiagnosisStatusContext(diagnosis diagnosisv1.Diagnosis, key string, value interface{}) (diagnosisv1.Diagnosis, error) {
	if diagnosis.Status.Context == nil {
		diagnosis.Status.Context = new(runtime.RawExtension)
	}
	current, err := diagnosis.Status.Context.MarshalJSON()
	if err != nil {
		return diagnosis, err
	}

	// Parsed context will be nil if raw data is empty.
	// Use map[string]interface{} instead of map[string][]byte for readability in json or yaml format.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return diagnosis, err
	}

	// Reinitialize context if context is nil.
	if context == nil {
		context = make(map[string]interface{})
	}
	context[key] = value
	result, err := json.Marshal(context)
	if err != nil {
		return diagnosis, err
	}

	err = diagnosis.Status.Context.UnmarshalJSON(result)
	if err != nil {
		return diagnosis, err
	}

	return diagnosis, nil
}

// GetDiagnosisSpecContext gets spec context field of an diagnosis with provided key.
func GetDiagnosisSpecContext(diagnosis diagnosisv1.Diagnosis, key string) ([]byte, error) {
	if diagnosis.Spec.Context == nil {
		return nil, fmt.Errorf("diagnosis spec context nil")
	}
	current, err := diagnosis.Spec.Context.MarshalJSON()
	if err != nil {
		return nil, err
	}

	// Parsed context will be nil if raw data is empty.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return nil, err
	}

	// Return error if diagnosis spec context is empty.
	if context == nil {
		return nil, fmt.Errorf("diagnosis spec context empty")
	}
	value, ok := context[key]
	if !ok {
		return nil, fmt.Errorf("spec context key not exist: %s", key)
	}

	result, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// GetDiagnosisStatusContext gets status context field of an diagnosis with provided key.
func GetDiagnosisStatusContext(diagnosis diagnosisv1.Diagnosis, key string) ([]byte, error) {
	if diagnosis.Status.Context == nil {
		return nil, fmt.Errorf("diagnosis status context nil")
	}
	current, err := diagnosis.Status.Context.MarshalJSON()
	if err != nil {
		return nil, err
	}

	// Parsed context will be nil if raw data is empty.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return nil, err
	}

	// Return error if diagnosis status context is empty.
	if context == nil {
		return nil, fmt.Errorf("diagnosis status context empty")
	}
	value, ok := context[key]
	if !ok {
		return nil, fmt.Errorf("status context key not exist: %s", key)
	}

	result, err := json.Marshal(value)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// RemoveDiagnosisSpecContext removes spec context field of an diagnosis with provided key.
func RemoveDiagnosisSpecContext(diagnosis diagnosisv1.Diagnosis, key string) (diagnosisv1.Diagnosis, bool, error) {
	if diagnosis.Spec.Context == nil {
		return diagnosis, true, nil
	}
	current, err := diagnosis.Spec.Context.MarshalJSON()
	if err != nil {
		return diagnosis, false, err
	}

	// Parsed context will be nil if raw data is empty.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return diagnosis, false, err
	}

	// Delete value with provided key from context.
	if context == nil {
		return diagnosis, true, nil
	}
	delete(context, key)

	result, err := json.Marshal(context)
	if err != nil {
		return diagnosis, false, err
	}

	err = diagnosis.Spec.Context.UnmarshalJSON(result)
	if err != nil {
		return diagnosis, false, err
	}

	return diagnosis, true, nil
}

// RemoveDiagnosisStatusContext removes status context field of an diagnosis with provided key.
func RemoveDiagnosisStatusContext(diagnosis diagnosisv1.Diagnosis, key string) (diagnosisv1.Diagnosis, bool, error) {
	if diagnosis.Status.Context == nil {
		return diagnosis, true, nil
	}
	current, err := diagnosis.Status.Context.MarshalJSON()
	if err != nil {
		return diagnosis, false, err
	}

	// Parsed context will be nil if raw data is empty.
	context := make(map[string]interface{})
	err = json.Unmarshal(current, &context)
	if err != nil {
		return diagnosis, false, err
	}

	// Delete value with provided key from context.
	if context == nil {
		return diagnosis, true, nil
	}
	delete(context, key)

	result, err := json.Marshal(context)
	if err != nil {
		return diagnosis, false, err
	}

	err = diagnosis.Status.Context.UnmarshalJSON(result)
	if err != nil {
		return diagnosis, false, err
	}

	return diagnosis, true, nil
}

// RetrievePodsOnNode retrieves all pods on the provided node.
func RetrievePodsOnNode(pods []corev1.Pod, nodeName string) []corev1.Pod {
	podsOnNode := make([]corev1.Pod, 0)
	for _, pod := range pods {
		if pod.Spec.NodeName == nodeName {
			podsOnNode = append(podsOnNode, pod)
		}
	}

	return podsOnNode
}

// RetrieveDiagnosesOnNode retrieves all diagnoses on the provided node.
func RetrieveDiagnosesOnNode(diagnoses []diagnosisv1.Diagnosis, nodeName string) []diagnosisv1.Diagnosis {
	diagnosesOnNode := make([]diagnosisv1.Diagnosis, 0)
	for _, diagnosis := range diagnoses {
		if diagnosis.Spec.NodeName == nodeName {
			diagnosesOnNode = append(diagnosesOnNode, diagnosis)
		}
	}

	return diagnosesOnNode
}

// GetTotalBytes gets total bytes in filesystem.
func GetTotalBytes(path string) uint64 {
	var stat syscall.Statfs_t
	syscall.Statfs(path, &stat)

	return stat.Blocks * uint64(stat.Bsize)
}

// GetFreeBytes gets free bytes in filesystem.
func GetFreeBytes(path string) uint64 {
	var stat syscall.Statfs_t
	syscall.Statfs(path, &stat)

	return stat.Bfree * uint64(stat.Bsize)
}

// GetAvailableBytes gets available bytes in filesystem.
func GetAvailableBytes(path string) uint64 {
	var stat syscall.Statfs_t
	syscall.Statfs(path, &stat)

	return stat.Bavail * uint64(stat.Bsize)
}

// GetUsedBytes gets used bytes in filesystem.
func GetUsedBytes(path string) uint64 {
	var stat syscall.Statfs_t
	syscall.Statfs(path, &stat)

	return (stat.Blocks - stat.Bfree) * uint64(stat.Bsize)
}

// RunCommandExecutor runs the command with timeout and updates the result into command executor.
func RunCommandExecutor(commandExecutorSpec diagnosisv1.CommandExecutorSpec, log logr.Logger) (diagnosisv1.CommandExecutorStatus, error) {
	commandExecutorStatus := diagnosisv1.CommandExecutorStatus{
		Command: commandExecutorSpec.Command,
		Type:    commandExecutorSpec.Type,
	}

	if len(commandExecutorSpec.Command) < 1 {
		err := fmt.Errorf("invalid command")
		commandExecutorStatus.Error = err.Error()
		return commandExecutorStatus, err
	}

	var buf bytes.Buffer
	command := exec.Command(commandExecutorSpec.Command[0], commandExecutorSpec.Command[1:]...)
	// Setting a new process group id to avoid suicide.
	command.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
	command.Stdout = &buf
	command.Stderr = &buf
	err := command.Start()
	if err != nil {
		commandExecutorStatus.Error = err.Error()
		return commandExecutorStatus, err
	}

	// Wait and signal completion of command.
	done := make(chan error)
	go func() {
		done <- command.Wait()
	}()

	timeout := time.After(time.Duration(commandExecutorSpec.TimeoutSeconds) * time.Second)
	select {
	// Kill the process if timeout happened.
	case <-timeout:
		// Kill the process and all of its children with its process group id.
		pgid, err := syscall.Getpgid(command.Process.Pid)
		if err != nil {
			log.Error(err, "failed to get process group id on command timed out", "command", commandExecutorSpec.Command)
		} else {
			err = syscall.Kill(-pgid, syscall.SIGKILL)
			if err != nil {
				log.Error(err, "failed to kill process on command timed out", "command", commandExecutorSpec.Command)
			}
		}

		err = fmt.Errorf("command %v timed out", commandExecutorSpec.Command)
		commandExecutorStatus.Error = err.Error()
		return commandExecutorStatus, fmt.Errorf("command %v timed out", commandExecutorSpec.Command)
	// Set output and error if command completed before timeout.
	case err := <-done:
		if err != nil {
			commandExecutorStatus.Stderr = buf.String()
			commandExecutorStatus.Error = err.Error()
		} else {
			commandExecutorStatus.Stdout = buf.String()
		}
	}

	return commandExecutorStatus, nil
}

// RunProfiler runs profiling and updates the result into profiler.
func RunProfiler(ctx context.Context, name string, namespace string, bindAddress string, dataRoot string, profilerSpec diagnosisv1.ProfilerSpec, podReference *diagnosisv1.PodReference, cli client.Client, log logr.Logger) (diagnosisv1.ProfilerStatus, error) {
	profilerStatus := diagnosisv1.ProfilerStatus{
		Name: profilerSpec.Name,
		Type: profilerSpec.Type,
	}

	switch {
	case profilerSpec.Go != nil:
		endpoint, err := RunGoProfiler(name, namespace, bindAddress, profilerSpec, podReference, dataRoot, cli, log)
		if err != nil {
			profilerStatus.Error = err.Error()
			return profilerStatus, err
		}
		profilerStatus.Endpoint = endpoint
	case profilerSpec.Java != nil:
		endpoint, err := RunJavaProfiler(name, namespace, bindAddress, profilerSpec, podReference, dataRoot, cli, log)
		if err != nil {
			profilerStatus.Error = err.Error()
			return profilerStatus, err
		}
		profilerStatus.Endpoint = endpoint
	default:
		err := fmt.Errorf("profiler not specified")
		profilerStatus.Error = err.Error()
		return profilerStatus, err
	}

	return profilerStatus, nil
}

// RunGoProfiler runs go profiling with timeout and updates the result into go profiler.
func RunGoProfiler(name string, namespace string, bindAddress string, profilerSpec diagnosisv1.ProfilerSpec, podReference *diagnosisv1.PodReference, dataRoot string, cli client.Client, log logr.Logger) (string, error) {
	if profilerSpec.Go == nil {
		return "", fmt.Errorf("go profiler not specified")
	}

	port, err := GetAvailablePort()
	if err != nil {
		return "", err
	}
	endpoint := fmt.Sprintf("%s:%d", bindAddress, port)

	// Add timeout seconds for cpu profile
	timeout := time.Duration(5) * time.Second
	source := fmt.Sprintf("%s%s%s", profilerSpec.Go.Source, "/debug/pprof/", strings.ToLower(string(profilerSpec.Go.Type)))
	if profilerSpec.Go.Type == diagnosisv1.CPUGoProfilerType {
		timeout += time.Duration(30) * time.Second
		source = fmt.Sprintf("%s?timeout=30s", source)
	}

	// Set go profiler directory
	now := time.Now().Format("20060102150405")
	datadir := filepath.Join(dataRoot, "profilers/go/pprof")
	if podReference == nil {
		datadir = filepath.Join(datadir, now)
	} else {
		datadir = filepath.Join(datadir, podReference.Namespace+"."+podReference.Name+"."+podReference.ContainerName, now)
	}

	if _, err := os.Stat(datadir); os.IsNotExist(err) {
		err := os.MkdirAll(datadir, os.ModePerm)
		if err != nil {
			return "", err
		}
	}
	// Set go profiler file name
	datafile := fmt.Sprintf("%s.%s.%s.%s.prof", namespace, name, profilerSpec.Name, profilerSpec.Go.Type)

	// HTTPS source
	if strings.HasPrefix(profilerSpec.Go.Source, "https") {
		name := profilerSpec.Go.TLS.SecretReference.Name
		namespace := profilerSpec.Go.TLS.SecretReference.Namespace

		secretData, err := GetSecretData(cli, name, namespace)
		if err != nil {
			return "", err
		}

		tokenByte, ok := secretData[v1.ServiceAccountTokenKey]
		if !ok {
			return "", fmt.Errorf("secret token is not specified")

		}
		caByte, ok := secretData[v1.ServiceAccountRootCAKey]
		if !ok {
			return "", fmt.Errorf("secret ca.crt is not specified")
		}

		err = DownloadProfileFile(fmt.Sprintf("%s/%s", datadir, datafile), source, tokenByte, caByte, timeout)
		if err != nil {
			return "", fmt.Errorf("download file failed with error: %s", err)
		}
	} else {
		err = DownloadProfileFile(fmt.Sprintf("%s/%s", datadir, datafile), source, nil, nil, timeout)
		if err != nil {
			return "", fmt.Errorf("download file failed with error: %s", err)
		}
	}
	var buf bytes.Buffer
	command := exec.Command("go", "tool", "pprof", "-no_browser", fmt.Sprintf("-http=%s", endpoint), fmt.Sprintf("%s/%s", datadir, datafile))
	// Setting a new process group id to avoid suicide.
	command.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}
	command.Stdout = &buf
	command.Stderr = &buf
	err = command.Start()
	if err != nil {
		return "", err
	}

	ctx, cancel := context.WithCancel(context.Background())

	// Start go profiler.
	exit := make(chan error)
	go func() {
		defer cancel()
		exit <- command.Wait()
	}()

	// Shutdown go profiler with expiration duration.
	go func() {
		select {
		// Wait for go profiler error.
		case <-ctx.Done():
			return
		// Wait for expiration and shutdown go profiler http server by killing the profiler process.
		case <-time.After(time.Duration(profilerSpec.ExpirationSeconds) * time.Second):
			// Kill the process and all of its children with its process group id.
			pgid, err := syscall.Getpgid(command.Process.Pid)
			if err != nil {
				log.Error(err, "failed to get process group id on go profiler expired", "source", profilerSpec.Go.Source)
			} else {
				err = syscall.Kill(-pgid, syscall.SIGKILL)
				if err != nil {
					log.Error(err, "failed to kill process on go profiler expired", "source", profilerSpec.Go.Source)
				}
			}
		}

		// Set profiler status as expired.
		err = SetProfilerExipred(name, namespace, profilerSpec, cli, log)
		if err != nil {
			log.Error(err, "unable to update Diagnosis")
		}
	}()

	return endpoint, err
}

// DownloadProfileFile do http request to download profile file and write into specified filepath
func DownloadProfileFile(filepath string, source string, token []byte, ca []byte, timeout time.Duration) error {
	client := &http.Client{
		Timeout: timeout,
	}
	if token != nil {
		conf := &transport.Config{
			TLS: transport.TLSConfig{
				CAData: ca,
			},
			BearerToken: string(token),
		}
		transport, err := transport.New(conf)
		if err != nil {
			return err
		}
		client.Transport = transport
	}
	req, err := http.NewRequest("GET", source, nil)
	if err != nil {
		return err
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	return err
}

// GetSecretData obtain secret.data from specified secret
func GetSecretData(cli client.Client, name string, namespace string) (map[string][]byte, error) {
	var secret corev1.Secret
	ctx := context.Background()
	if err := cli.Get(ctx, client.ObjectKey{
		Name:      name,
		Namespace: namespace,
	}, &secret); err != nil {
		return nil, err
	}
	return secret.Data, nil
}

// RunJavaProfiler runs java profiling with timeout and updates the result into java profiler.
func RunJavaProfiler(name string, namespace string, bindAddress string, profilerSpec diagnosisv1.ProfilerSpec, podReference *diagnosisv1.PodReference, dataRoot string, cli client.Client, log logr.Logger) (string, error) {
	if profilerSpec.Java == nil {
		return "", fmt.Errorf("java profiler not specified")
	}

	port, err := GetAvailablePort()
	if err != nil {
		return "", err
	}
	endpoint := fmt.Sprintf("%s:%d", bindAddress, port)

	switch {
	case profilerSpec.Java.Type == diagnosisv1.ArthasJavaProfilerType:
		return "", fmt.Errorf("arthas java profiler not implemented")
	case profilerSpec.Java.Type == diagnosisv1.MemoryAnalyzerJavaProfilerType:
		// Validate the hprof file path.
		if !filepath.IsAbs(profilerSpec.Java.HPROFFilePath) {
			return "", fmt.Errorf("hprof file path is not absolute")
		}
		fileInfo, err := os.Stat(profilerSpec.Java.HPROFFilePath)
		if os.IsNotExist(err) {
			return "", fmt.Errorf("hprof file does not exist")
		}

		// Create directory to store profiler result.
		now := time.Now().Format("20060102150405")
		dirname := filepath.Join(dataRoot, "profilers/java/memory")
		if podReference == nil {
			dirname = filepath.Join(dirname, now)
		} else {
			dirname = filepath.Join(dirname, podReference.Namespace+"."+podReference.Name+"."+podReference.ContainerName, now)
		}
		if _, err := os.Stat(dirname); os.IsNotExist(err) {
			err := os.MkdirAll(dirname, os.ModePerm)
			if err != nil {
				return "", err
			}
		}

		// Collect hprof file.
		_, err = BlockingRunCommandWithTimeout([]string{"mv", profilerSpec.Java.HPROFFilePath, dirname}, profilerSpec.TimeoutSeconds)
		if err != nil {
			return "", fmt.Errorf("collect hprof file %s with error %v", profilerSpec.Java.HPROFFilePath, err)
		}

		// Parse hprof file with eclipse memory analyzer.
		hprofFilePath := filepath.Join(dirname, fileInfo.Name())
		err = ParseHPROFFile(dirname, hprofFilePath, profilerSpec.TimeoutSeconds)
		if err != nil {
			return "", err
		}

		// Decompress result archives from hprof files by executing "unzip" command.
		leakSuspectsDirectoryPath, systemOverviewDirectoryPath, topComponentsDirectoryPath, err := DecompressHPROFFileArchives(dirname, fileInfo, profilerSpec.TimeoutSeconds)
		if err != nil {
			return "", err
		}

		// Start memory analyzer http server with leak suspects, system overview and top components files.
		err = StartMemoryAnalyzerHTTPServer(name, namespace, profilerSpec, endpoint, leakSuspectsDirectoryPath, systemOverviewDirectoryPath, topComponentsDirectoryPath, cli, log)
		if err != nil {
			return "", err
		}
	}

	return endpoint, nil
}

// SystemdUnitProperties returns a slice which contains all properties of specified systemd unit.
// See systemctl(1) linux manual page for more details:
//
// https://www.man7.org/linux/man-pages/man1/systemctl.1.html
func SystemdUnitProperties(name string) ([]types.Property, error) {
	command := make([]string, 0)
	// Get properties of the manager itself if systemd unit name is empty.
	if name == "" {
		command = []string{"nsenter", "-t", "1", "-m", "-p", "-n", "-i", "-u", "systemctl", "show", "--no-page"}
	} else {
		command = []string{"nsenter", "-t", "1", "-m", "-p", "-n", "-i", "-u", "systemctl", "show", "--no-page", name}
	}

	out, err := BlockingRunCommandWithTimeout(command, 10)
	if err != nil {
		return nil, fmt.Errorf("execute command systemctl on unit %s with error %v", name, err)
	}

	buf := bytes.NewBuffer(out)
	properties, err := types.ParseProperties(buf)
	if err != nil {
		return nil, err
	}

	return properties, nil
}

// DiskUsage calculates the disk usage of a directory by executing "du" command.
func DiskUsage(path string) (int, error) {
	// Uses the same niceness level as cadvisor.fs does when running "du".
	// Uses -B 1 to always scale to a blocksize of 1 byte.
	// Set 10 seconds timeout for "du" command.
	command := []string{"nice", "-n", "19", "du", "-s", "-B", "1", path}
	out, err := BlockingRunCommandWithTimeout(command, 60)
	if err != nil {
		return 0, fmt.Errorf("execute command du ($ nice -n 19 du -s -B 1) on path %s with error %v", path, err)
	}

	size, err := strconv.Atoi(strings.Fields(string(out))[0])
	if err != nil {
		return 0, fmt.Errorf("unable to parse du output %s due to error %v", out, err)
	}

	return size, nil
}

// RemoveFile removes a file or a directory by executing "rm" command.
func RemoveFile(path string) error {
	command := []string{"rm", "-r", "-f", path}
	_, err := BlockingRunCommandWithTimeout(command, 60)
	if err != nil {
		return fmt.Errorf("execute command rm ($ rm -r -f) on path %s with error %v", path, err)
	}

	return nil
}

// ParseHPROFFile parses hprof file with eclipse memory analyzer. The results are stored in zip files under
// the same directory of hprof file.
// It takes command working directory, hprof file path and timeout seconds as parameters.
func ParseHPROFFile(workdir string, path string, timeoutSeconds int32) error {
	_, err := BlockingRunCommandWithTimeout([]string{"/mat/ParseHeapDump.sh", path, MemoryAnalyzerLeakSuspectsReportAPI, MemoryAnalyzerSystemOverviewReportAPI, MemoryAnalyzerTopComponentsReportAPI}, timeoutSeconds)
	if err != nil {
		return fmt.Errorf("unable to parse hprof file %s with error %v", path, err)
	}

	return nil
}

// DecompressHPROFFileArchives decompresses result archives from hprof files by executing "unzip" command.
func DecompressHPROFFileArchives(dirname string, fileInfo os.FileInfo, timeoutSeconds int32) (string, string, string, error) {
	leakSuspectsFilePath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerLeakSuspectsSuffix+".zip")
	leakSuspectsDirectoryPath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerLeakSuspectsSuffix)
	err := Unzip(leakSuspectsFilePath, leakSuspectsDirectoryPath, timeoutSeconds)
	if err != nil {
		return "", "", "", err
	}

	systemOverviewFilePath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerSystemOverviewSuffix+".zip")
	systemOverviewDirectoryPath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerSystemOverviewSuffix)
	err = Unzip(systemOverviewFilePath, systemOverviewDirectoryPath, timeoutSeconds)
	if err != nil {
		return "", "", "", err
	}

	topComponentsFilePath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerTopComponentsSuffix+".zip")
	topComponentsDirectoryPath := filepath.Join(dirname, strings.TrimSuffix(fileInfo.Name(), filepath.Ext(fileInfo.Name()))+MemoryAnalyzerTopComponentsSuffix)
	err = Unzip(topComponentsFilePath, topComponentsDirectoryPath, timeoutSeconds)
	if err != nil {
		return "", "", "", err
	}

	return leakSuspectsDirectoryPath, systemOverviewDirectoryPath, topComponentsDirectoryPath, nil
}

// Unzip decompresses a zip archive, moving all files and folders within the zip file to an output directory
// by executing "unzip" command.
// It takes source zip file, destination output directory and timeout seconds as parameters.
func Unzip(src string, dst string, timeoutSeconds int32) error {
	_, err := BlockingRunCommandWithTimeout([]string{"unzip", src, "-d", dst}, timeoutSeconds)
	if err != nil {
		return fmt.Errorf("unzip file %s to %s with error %v", src, dst, err)
	}

	return nil
}

// StartMemoryAnalyzerHTTPServer starts memory analyzer http server with leak suspects, system overview
// and top components files and shutdown memory analyzer http server with expiration duration.
func StartMemoryAnalyzerHTTPServer(name string, namespace string, profilerSpec diagnosisv1.ProfilerSpec, endpoint string, leakSuspectsDirectoryPath string, systemOverviewDirectoryPath string, topComponentsDirectoryPath string, cli client.Client, log logr.Logger) error {
	// Handle leak suspects, system overview and top components files.
	mux := http.NewServeMux()
	leakSuspectsFileServer := http.FileServer(http.Dir(leakSuspectsDirectoryPath))
	systemOverviewFileServer := http.FileServer(http.Dir(systemOverviewDirectoryPath))
	topComponentsFileServer := http.FileServer(http.Dir(topComponentsDirectoryPath))
	mux.HandleFunc("/", MemoryAnalyzerHomepageHandler)
	mux.Handle("/leaksuspects/", http.StripPrefix("/leaksuspects/", leakSuspectsFileServer))
	mux.Handle("/systemoverview/", http.StripPrefix("/systemoverview/", systemOverviewFileServer))
	mux.Handle("/topcomponents/", http.StripPrefix("/topcomponents/", topComponentsFileServer))

	ctx, cancel := context.WithCancel(context.Background())
	server := &http.Server{
		Addr:    endpoint,
		Handler: mux,
	}

	// Start memory analyzer http server.
	go func() {
		defer cancel()
		err := server.ListenAndServe()
		if err == http.ErrServerClosed {
			log.Info("memory analyzer http server closed")
		} else if err != nil {
			log.Error(err, "failed to start memory analyzer http server")
		}
	}()

	// Shutdown memory analyzer http server with expiration duration.
	go func() {
		select {
		// Wait for memory analyzer http server error.
		case <-ctx.Done():
			return
		// Wait for expiration.
		case <-time.After(time.Duration(profilerSpec.ExpirationSeconds) * time.Second):
			err := server.Shutdown(ctx)
			if err != nil {
				log.Error(err, "failed to shutdown memory analyzer http server")
			}

			// Set profiler status as expired.
			err = SetProfilerExipred(name, namespace, profilerSpec, cli, log)
			if err != nil {
				log.Error(err, "unable to update Diagnosis")
			}
		}
	}()

	return nil
}

// SetProfilerExipred sets diagnosis profiler status as expired.
func SetProfilerExipred(name string, namespace string, profilerSpec diagnosisv1.ProfilerSpec, cli client.Client, log logr.Logger) error {
	ctx := context.Background()

	log.Info("profiler expired", "diagnosis", client.ObjectKey{
		Name:      name,
		Namespace: namespace,
	}, "profiler", profilerSpec)

	var diagnosis diagnosisv1.Diagnosis
	if err := cli.Get(ctx, client.ObjectKey{
		Name:      name,
		Namespace: namespace,
	}, &diagnosis); err != nil {
		return err
	}

	for i := 0; i < len(diagnosis.Status.Profilers); i++ {
		if diagnosis.Status.Profilers[i].Name == profilerSpec.Name && diagnosis.Status.Profilers[i].Type == profilerSpec.Type {
			diagnosis.Status.Profilers[i].Endpoint = ProfilerEndpointExpiredValue
		}
	}

	if err := cli.Status().Update(ctx, &diagnosis); err != nil {
		return err
	}

	return nil
}

// MemoryAnalyzerHomepageHandler handles memory analyzer homepage requests.
func MemoryAnalyzerHomepageHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html")
	w.Write([]byte(MemoryAnalyzerHomepage))
}

// BlockingRunCommandWithTimeout executes command in blocking mode with timeout seconds.
func BlockingRunCommandWithTimeout(command []string, timeoutSeconds int32) ([]byte, error) {
	timeoutCommand := []string{"timeout", fmt.Sprintf("%ds", timeoutSeconds)}
	timeoutCommand = append(timeoutCommand, command...)
	out, err := exec.Command(timeoutCommand[0], timeoutCommand[1:]...).CombinedOutput()
	if err != nil {
		return out, err
	}

	return out, nil
}

// GetAvailablePort returns a free open port that is ready to use.
func GetAvailablePort() (int, error) {
	addr, err := net.ResolveTCPAddr("tcp", "0.0.0.0:0")
	if err != nil {
		return 0, err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return 0, err
	}
	defer l.Close()

	return l.Addr().(*net.TCPAddr).Port, nil
}

// ValidateProfilerSpecs tests that all specified ProfilerSpecs has valid data.
func ValidateProfilerSpecs(profilerSpecs []diagnosisv1.ProfilerSpec) error {
	allNames := sets.String{}
	for _, profilerSpec := range profilerSpecs {
		if allNames.Has(profilerSpec.Name) {
			return fmt.Errorf("duplicated profiler name: %s", profilerSpec.Name)
		}
		allNames.Insert(profilerSpec.Name)
	}

	return nil
}

// MatchPrometheusAlert reports whether the diagnosis contains all match of the regular expression pattern
// defined in prometheus alert template.
func MatchPrometheusAlert(prometheusAlertTemplate diagnosisv1.PrometheusAlertTemplate, diagnosis diagnosisv1.Diagnosis) (bool, error) {
	re, err := regexp.Compile(prometheusAlertTemplate.Regexp.AlertName)
	if err != nil {
		return false, err
	}
	if !re.MatchString(string(diagnosis.Spec.PrometheusAlert.Labels[model.AlertNameLabel])) {
		return false, nil
	}

	// Template label key must be identical to the prometheus alert label key.
	// Template label value should be a regular expression.
	for templateKey, templateValue := range prometheusAlertTemplate.Regexp.Labels {
		value, ok := diagnosis.Spec.PrometheusAlert.Labels[templateKey]
		if !ok {
			return false, nil
		}

		re, err := regexp.Compile(string(templateValue))
		if err != nil {
			return false, err
		}
		if !re.MatchString(string(value)) {
			return false, nil
		}
	}

	// Template annotation key must be identical to the prometheus alert annotation key.
	// Template annotation value should be a regular expression.
	for templateKey, templateValue := range prometheusAlertTemplate.Regexp.Annotations {
		value, ok := diagnosis.Spec.PrometheusAlert.Annotations[templateKey]
		if !ok {
			return false, nil
		}

		re, err := regexp.Compile(string(templateValue))
		if err != nil {
			return false, err
		}
		if !re.MatchString(string(value)) {
			return false, nil
		}
	}

	re, err = regexp.Compile(prometheusAlertTemplate.Regexp.StartsAt)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.PrometheusAlert.StartsAt.String()) {
		return false, nil
	}

	re, err = regexp.Compile(prometheusAlertTemplate.Regexp.EndsAt)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.PrometheusAlert.EndsAt.String()) {
		return false, nil
	}

	re, err = regexp.Compile(prometheusAlertTemplate.Regexp.GeneratorURL)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.PrometheusAlert.GeneratorURL) {
		return false, nil
	}

	return true, nil
}

// MatchKubernetesEvent reports whether the diagnosis contains all match of the regular expression pattern
// defined in kubernetes event template.
func MatchKubernetesEvent(kubernetesEventTemplate diagnosisv1.KubernetesEventTemplate, diagnosis diagnosisv1.Diagnosis) (bool, error) {
	re, err := regexp.Compile(kubernetesEventTemplate.Regexp.Name)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Name) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Namespace)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Namespace) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.Kind)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.Kind) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.Namespace)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.Namespace) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.Name)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.Name) {
		return false, nil
	}

	re, err = regexp.Compile(string(kubernetesEventTemplate.Regexp.InvolvedObject.UID))
	if err != nil {
		return false, err
	}
	if !re.MatchString(string(diagnosis.Spec.KubernetesEvent.InvolvedObject.UID)) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.APIVersion)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.APIVersion) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.ResourceVersion)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.ResourceVersion) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.InvolvedObject.FieldPath)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.InvolvedObject.FieldPath) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Reason)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Reason) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Message)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Message) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Source.Component)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Source.Component) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Source.Host)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Source.Host) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.FirstTimestamp)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.FirstTimestamp.String()) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.LastTimestamp)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.LastTimestamp.String()) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Count)
	if err != nil {
		return false, err
	}
	if !re.MatchString(strconv.Itoa(int(diagnosis.Spec.KubernetesEvent.Count))) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Type)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Type) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.Action)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.Action) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.ReportingController)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.ReportingController) {
		return false, nil
	}

	re, err = regexp.Compile(kubernetesEventTemplate.Regexp.ReportingInstance)
	if err != nil {
		return false, err
	}
	if !re.MatchString(diagnosis.Spec.KubernetesEvent.ReportingInstance) {
		return false, nil
	}

	return true, nil
}
